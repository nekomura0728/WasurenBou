# わすれん棒 - 開発計画書

## 1. 実装優先度とロードマップ

### 1.1 開発フェーズ

#### Phase 1: コアMVP（4週間）
**目標**: 基本的なリマインダー機能を動作させる

**Week 1: プロジェクトセットアップ + 基本UI**
- Xcodeプロジェクト作成（iOS）
- Core Data設定
- SwiftUI基本画面実装
- 音声認識権限まわり

**Week 2: 音声入力システム**  
- Speech Framework実装
- 自然言語処理（時間抽出）
- 音声→リマインダー変換ロジック
- 基本的なNLPパーサー

**Week 3: 通知システム**
- Local Notification実装
- 段階的通知ロジック
- 通知アクション（完了・スヌーズ）
- バックグラウンド処理

**Week 4: 品質向上・申請準備**
- UI/UX調整・アクセシビリティ仕上げ
- 例外/エラーUIの磨き込み
- ストア素材準備・申請準備

#### Phase 2: 拡張機能（3週間）
- AI学習機能
- 天気・位置連動
- テンプレート機能拡充
- UI/UXブラッシュアップ

#### Phase 3: リリース準備（2週間）
- App Store申請
- マーケティング準備
- バグ修正・最適化

### 1.2 技術的優先順位

**🚨 Critical Path（ブロッカーになる機能）**
1. **Core Data + 基本CRUD** - 全機能の基盤
2. **音声認識 + NLP** - コア価値提案
3. **通知システム** - 差別化要素

**⚡ High Priority（早期実装で価値向上）**
5. 段階的通知エスカレーション
6. 優しいメッセージング
7. よく使うテンプレート
8. 完了時の褒め機能

**📈 Medium Priority（体験向上）**
9. 音声認識精度向上
10. UI/UXポリッシュ
11. エラーハンドリング
12. パフォーマンス最適化

## 2. プロジェクト初期セットアップ

### 2.1 Xcodeプロジェクト作成手順

```bash
# 1. 新規プロジェクト作成
# File > New > Project > iOS > App
# Project Name: WasurenBou
# Bundle ID: com.yourcompany.wasurenBou
# Language: Swift, UI: SwiftUI

# 2. watchOS Targetの追加は当面不要

# 3. 必要なCapabilitiesを有効化
# Project Settings > Signing & Capabilities:
# - Background Modes (Background processing)
# - Push Notifications  
# - Siri
```

### 2.2 フォルダ構成
```
WasurenBou/
├── App/
│   ├── WasurenBouApp.swift
│   ├── ContentView.swift
│   └── Info.plist
├── Models/
│   ├── Reminder.swift
│   ├── ReminderTemplate.swift
│   └── WasurenBou.xcdatamodeld
├── ViewModels/
│   ├── ReminderViewModel.swift
│   └── SpeechViewModel.swift
├── Views/
│   ├── ReminderListView.swift
│   ├── VoiceInputView.swift
│   └── Components/
├── Services/
│   ├── ReminderRepository.swift
│   ├── NotificationService.swift
│   ├── SpeechRecognitionService.swift
│   └── NLPParser.swift
├── Extensions/
│   ├── Date+Extensions.swift
│   └── String+Extensions.swift
└── Resources/
    ├── Sounds/
    └── Colors.xcassets
```

### 2.3 初期依存関係設定

```swift
// Package.swift または SPMで追加
dependencies: [
    // 必須ではないが、検討対象
    .package(url: "https://github.com/apple/swift-algorithms", from: "1.0.0"),
]
```

## 3. コア機能プロトタイプ実装計画

### 3.1 Week 1: プロジェクト基盤

**Day 1-2: プロジェクトセットアップ**
```swift
// WasurenBouApp.swift
@main
struct WasurenBouApp: App {
    let persistenceController = PersistenceController.shared
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environment(\.managedObjectContext, persistenceController.container.viewContext)
        }
    }
}

// PersistenceController.swift  
class PersistenceController {
    static let shared = PersistenceController()
    
    let container: NSPersistentContainer
    
    init() {
        container = NSPersistentContainer(name: "WasurenBou")
        container.loadPersistentStores { _, error in
            if let error = error {
                fatalError("Core Data error: \(error)")
            }
        }
    }
}
```

**Day 3-4: Core Dataモデル実装**
```swift
// Reminder+CoreDataClass.swift
@objc(Reminder)
public class Reminder: NSManagedObject {
    // Core Data自動生成
}

// Reminder+CoreDataProperties.swift
extension Reminder {
    @NSManaged public var id: UUID
    @NSManaged public var title: String
    @NSManaged public var scheduledTime: Date
    @NSManaged public var isCompleted: Bool
    @NSManaged public var createdAt: Date
}
```

**Day 5: 基本UI実装**
```swift
// ContentView.swift - 最小構成
struct ContentView: View {
    @State private var showingVoiceInput = false
    
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                // 音声入力ボタン（プレースホルダー）
                Button("🎤 話しかける") {
                    showingVoiceInput = true
                }
                .font(.title2)
                .padding()
                .background(Color.blue.opacity(0.1))
                .cornerRadius(12)
                
                // リマインダー一覧（プレースホルダー）
                List {
                    Text("今日のリマインダーはありません")
                        .foregroundColor(.gray)
                }
                
                Spacer()
            }
            .navigationTitle("わすれん棒")
        }
    }
}
```

### 3.2 Week 2: 音声入力システム

**Day 1-2: Speech Framework実装**
```swift
// SpeechRecognitionService.swift
import Speech
import AVFoundation

class SpeechRecognitionService: ObservableObject {
    @Published var isRecording = false
    @Published var recognizedText = ""
    @Published var isAuthorized = false
    
    private let speechRecognizer = SFSpeechRecognizer(locale: Locale(identifier: "ja-JP"))
    private var recognitionRequest: SFSpeechAudioBufferRecognitionRequest?
    private var recognitionTask: SFSpeechRecognitionTask?
    private let audioEngine = AVAudioEngine()
    
    init() {
        Task {
            await requestPermissions()
        }
    }
    
    @MainActor
    private func requestPermissions() async {
        // 音声認識権限
        let speechStatus = await withCheckedContinuation { continuation in
            SFSpeechRecognizer.requestAuthorization { status in
                continuation.resume(returning: status)
            }
        }
        
        // マイク権限
        let micStatus = await withCheckedContinuation { continuation in
            AVAudioSession.sharedInstance().requestRecordPermission { granted in
                continuation.resume(returning: granted)
            }
        }
        
        self.isAuthorized = speechStatus == .authorized && micStatus
    }
    
    func startRecording() throws {
        // 前の認識をキャンセル
        recognitionTask?.cancel()
        recognitionTask = nil
        
        // オーディオセッション設定
        let audioSession = AVAudioSession.sharedInstance()
        try audioSession.setCategory(.record, mode: .measurement, options: .duckOthers)
        try audioSession.setActive(true, options: .notifyOthersOnDeactivation)
        
        // 認識リクエスト作成
        recognitionRequest = SFSpeechAudioBufferRecognitionRequest()
        guard let recognitionRequest = recognitionRequest else {
            throw SpeechError.recognitionRequestFailed
        }
        
        recognitionRequest.shouldReportPartialResults = true
        
        // オーディオエンジン設定
        let inputNode = audioEngine.inputNode
        let recordingFormat = inputNode.outputFormat(forBus: 0)
        
        inputNode.installTap(onBus: 0, bufferSize: 1024, format: recordingFormat) { buffer, _ in
            recognitionRequest.append(buffer)
        }
        
        // 認識開始
        recognitionTask = speechRecognizer?.recognitionTask(with: recognitionRequest) { [weak self] result, error in
            DispatchQueue.main.async {
                if let result = result {
                    self?.recognizedText = result.bestTranscription.formattedString
                }
                
                if error != nil || result?.isFinal == true {
                    self?.stopRecording()
                }
            }
        }
        
        audioEngine.prepare()
        try audioEngine.start()
        
        isRecording = true
        recognizedText = ""
    }
    
    func stopRecording() {
        audioEngine.stop()
        audioEngine.inputNode.removeTap(onBus: 0)
        
        recognitionRequest?.endAudio()
        recognitionRequest = nil
        recognitionTask?.cancel()
        recognitionTask = nil
        
        isRecording = false
    }
}

enum SpeechError: Error {
    case recognitionRequestFailed
    case audioEngineFailed
}
```

**Day 3-4: NLPパーサー実装**
```swift
// NLPParser.swift
import Foundation
import NaturalLanguage

struct ReminderIntent {
    let title: String
    let scheduledTime: Date
    let type: ReminderType
}

enum ReminderType {
    case once
    case daily
    case weekly
}

class NLPParser {
    private let calendar = Calendar.current
    private let now = Date()
    
    func parseReminderIntent(from text: String) -> ReminderIntent? {
        let cleanText = text.trimmingCharacters(in: .whitespacesAndNewlines)
        
        // 時間表現を抽出
        let timeInfo = extractTimeExpression(from: cleanText)
        
        // アクション部分を抽出（時間表現を除いた部分）
        let action = extractAction(from: cleanText, removingTime: timeInfo?.originalText)
        
        guard let scheduledTime = timeInfo?.date,
              let actionText = action else {
            return nil
        }
        
        return ReminderIntent(
            title: actionText,
            scheduledTime: scheduledTime,
            type: .once
        )
    }
    
    private func extractTimeExpression(from text: String) -> (date: Date, originalText: String)? {
        // "2時間後" -> Date(now + 2 hours)
        if let match = text.range(of: #"(\d+)時間後"#, options: .regularExpression) {
            let matchText = String(text[match])
            if let hours = Int(matchText.replacingOccurrences(of: #"(\d+)時間後"#, with: "$1", options: .regularExpression)) {
                return (now.addingTimeInterval(TimeInterval(hours * 3600)), matchText)
            }
        }
        
        // "明日朝一" -> Date(tomorrow 8:00)
        if text.contains("明日朝一") || text.contains("明日の朝一") {
            let tomorrow = calendar.date(byAdding: .day, value: 1, to: now)!
            let morningTime = calendar.date(bySettingHour: 8, minute: 0, second: 0, of: tomorrow)!
            return (morningTime, "明日朝一")
        }
        
        // "30分後" -> Date(now + 30 minutes)  
        if let match = text.range(of: #"(\d+)分後"#, options: .regularExpression) {
            let matchText = String(text[match])
            if let minutes = Int(matchText.replacingOccurrences(of: #"(\d+)分後"#, with: "$1", options: .regularExpression)) {
                return (now.addingTimeInterval(TimeInterval(minutes * 60)), matchText)
            }
        }
        
        return nil
    }
    
    private func extractAction(from text: String, removingTime timeText: String?) -> String? {
        var actionText = text
        
        // 時間表現を除去
        if let timeText = timeText {
            actionText = actionText.replacingOccurrences(of: timeText, with: "")
        }
        
        // 「に」「を」などの助詞も除去
        actionText = actionText
            .replacingOccurrences(of: "に", with: "")
            .replacingOccurrences(of: "を", with: "")
            .trimmingCharacters(in: .whitespacesAndNewlines)
        
        return actionText.isEmpty ? nil : actionText
    }
}
```

### 3.3 Week 3: 通知システム

**Day 1-2: 基本通知実装**
```swift
// NotificationService.swift
import UserNotifications

class NotificationService {
    static let shared = NotificationService()
    
    func requestPermission() async -> Bool {
        let center = UNUserNotificationCenter.current()
        do {
            let granted = try await center.requestAuthorization(options: [.alert, .sound, .badge, .criticalAlert])
            return granted
        } catch {
            return false
        }
    }
    
    func scheduleReminder(_ reminder: Reminder) async throws {
        let center = UNUserNotificationCenter.current()
        
        // 既存の通知をキャンセル
        center.removePendingNotificationRequests(withIdentifiers: [reminder.id.uuidString])
        
        // 基本通知を作成
        let content = UNMutableNotificationContent()
        content.title = reminder.title
        content.body = "時間ですよ〜"
        content.sound = .default
        content.categoryIdentifier = "REMINDER_CATEGORY"
        
        // トリガー作成
        let components = Calendar.current.dateComponents([.year, .month, .day, .hour, .minute], 
                                                        from: reminder.scheduledTime)
        let trigger = UNCalendarNotificationTrigger(dateMatching: components, repeats: false)
        
        // リクエスト作成
        let request = UNNotificationRequest(
            identifier: reminder.id.uuidString,
            content: content, 
            trigger: trigger
        )
        
        try await center.add(request)
    }
}
```

**Day 3-5: 段階的通知システム**
```swift
// NotificationService.swift に追加
func scheduleEscalatingReminders(for reminder: Reminder) async throws {
    let center = UNUserNotificationCenter.current()
    let baseId = reminder.id.uuidString
    
    // 1回目: 優しい通知
    let first = createEscalatingNotification(
        id: "\(baseId)-1",
        title: reminder.title,
        body: "時間ですよ〜",
        time: reminder.scheduledTime,
        sound: .default,
        critical: false
    )
    
    // 2回目: 中程度通知（5分後）
    let second = createEscalatingNotification(
        id: "\(baseId)-2", 
        title: reminder.title,
        body: "大丈夫ですか？",
        time: reminder.scheduledTime.addingTimeInterval(300),
        sound: .default,
        critical: false
    )
    
    // 3回目: 緊急通知（10分後）
    let third = createEscalatingNotification(
        id: "\(baseId)-3",
        title: reminder.title,
        body: "！！",
        time: reminder.scheduledTime.addingTimeInterval(600), 
        sound: .defaultCritical,
        critical: true
    )
    
    try await center.add(first)
    try await center.add(second)
    try await center.add(third)
}

private func createEscalatingNotification(
    id: String,
    title: String,
    body: String,
    time: Date,
    sound: UNNotificationSound,
    critical: Bool
) -> UNNotificationRequest {
    let content = UNMutableNotificationContent()
    content.title = title
    content.body = body
    content.sound = sound
    content.categoryIdentifier = "REMINDER_CATEGORY"
    
    if critical {
        content.interruptionLevel = .critical
    }
    
    let components = Calendar.current.dateComponents([.year, .month, .day, .hour, .minute], from: time)
    let trigger = UNCalendarNotificationTrigger(dateMatching: components, repeats: false)
    
    return UNNotificationRequest(identifier: id, content: content, trigger: trigger)
}
```

## 4. テスト戦略と品質保証

### 4.1 テスト計画

**Unit Tests (Week 1-4で並行実装)**
```swift
// ReminderRepositoryTests.swift
import XCTest
@testable import WasurenBou

class ReminderRepositoryTests: XCTestCase {
    var repository: ReminderRepository!
    var mockContext: NSManagedObjectContext!
    
    override func setUp() {
        // テスト用In-Memory Core Dataセットアップ
    }
    
    func testSaveReminder() async throws {
        // Given
        let reminder = Reminder(title: "テスト", scheduledTime: Date())
        
        // When
        try await repository.saveReminder(reminder)
        
        // Then
        let saved = await repository.fetchActiveReminders()
        XCTAssertEqual(saved.count, 1)
    }
}

// NLPParserTests.swift
class NLPParserTests: XCTestCase {
    var parser: NLPParser!
    
    func testParseTimeExpression() {
        // Given
        let text = "2時間後に洗濯物取り込む"
        
        // When
        let intent = parser.parseReminderIntent(from: text)
        
        // Then
        XCTAssertNotNil(intent)
        XCTAssertEqual(intent?.title, "洗濯物取り込む")
    }
}
```

**Integration Tests**
```swift
// SpeechToReminderIntegrationTests.swift
class SpeechToReminderIntegrationTests: XCTestCase {
    func testFullWorkflow() async throws {
        // 音声認識 → NLP → データ保存 → 通知設定の全フロー
    }
}
```

**UI Tests（Week 4）**
```swift
// WasurenBouUITests.swift
class WasurenBouUITests: XCTestCase {
    func testVoiceInputFlow() throws {
        let app = XCUIApplication()
        app.launch()
        
        // 音声入力ボタンをタップ
        app.buttons["🎤 話しかける"].tap()
        
        // 権限ダイアログが表示されることを確認
        // （実際の音声テストはシミュレーターでは困難）
    }
}
```

### 4.2 品質保証チェックリスト

**コード品質**
- [ ] SwiftLint設定とルール遵守
- [ ] Code Coverage 80%以上
- [ ] メモリリークチェック（Instruments）
- [ ] パフォーマンステスト（音声認識レスポンス時間）

**機能テスト**
- [ ] 音声認識の精度テスト（様々な話し方）
- [ ] 通知の確実性テスト（バックグラウンド状態）
- [ ] Apple Watch連携テスト（当面対象外）
- [ ] 異常系のエラーハンドリング

**ユーザビリティテスト**
- [ ] 初回利用時のオンボーディング
- [ ] 権限取得フローのスムーズさ
- [ ] エラー時のメッセージの分かりやすさ

## 5. リスク管理と対策

### 5.1 技術リスク

**高リスク**
- **音声認識精度**: 方言・ノイズ環境での認識失敗
  - 対策: フォールバック用テキスト入力UI実装
- **通知制限**: iOS通知制限による通知失敗
  - 対策: Critical Alert権限申請、代替アラート手段

**中リスク** 
- **Apple Watch接続**: Bluetooth接続不安定
  - 対策: 接続状況に応じたUI表示、再接続機能
- **バッテリー消費**: 頻繁通知によるバッテリードレイン
  - 対策: 通知頻度の最適化、省電力モード

### 5.2 スケジュールリスク

**Week単位のマイルストーン**
- Week 1終了: 基本UI動作 → 遅れの場合はApple Watch対応を後回し
- Week 2終了: 音声入力動作 → 遅れの場合はテキスト入力で代替
- Week 3終了: 通知動作 → 遅れの場合は段階的通知は簡略化

これで開発計画が完成です！実装を始めるとしたら、どの機能から着手したいでしょうか？

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"id": "1", "content": "\u5b9f\u88c5\u512a\u5148\u5ea6\u3068\u958b\u767a\u30ed\u30fc\u30c9\u30de\u30c3\u30d7\u306e\u7b56\u5b9a", "status": "completed"}, {"id": "2", "content": "\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u521d\u671f\u30bb\u30c3\u30c8\u30a2\u30c3\u30d7\u624b\u9806", "status": "completed"}, {"id": "3", "content": "\u30b3\u30a2\u6a5f\u80fd\u306e\u30d7\u30ed\u30c8\u30bf\u30a4\u30d7\u5b9f\u88c5\u8a08\u753b", "status": "completed"}, {"id": "4", "content": "\u30c6\u30b9\u30c8\u6226\u7565\u3068\u54c1\u8cea\u4fdd\u8a3c\u8a08\u753b", "status": "completed"}]