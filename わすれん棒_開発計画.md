# ã‚ã™ã‚Œã‚“æ£’ - é–‹ç™ºè¨ˆç”»æ›¸

## 1. å®Ÿè£…å„ªå…ˆåº¦ã¨ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—

### 1.1 é–‹ç™ºãƒ•ã‚§ãƒ¼ã‚º

#### Phase 1: ã‚³ã‚¢MVPï¼ˆ4é€±é–“ï¼‰
**ç›®æ¨™**: åŸºæœ¬çš„ãªãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼æ©Ÿèƒ½ã‚’å‹•ä½œã•ã›ã‚‹

**Week 1: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— + åŸºæœ¬UI**
- Xcodeãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆï¼ˆiOSï¼‰
- Core Dataè¨­å®š
- SwiftUIåŸºæœ¬ç”»é¢å®Ÿè£…
- éŸ³å£°èªè­˜æ¨©é™ã¾ã‚ã‚Š

**Week 2: éŸ³å£°å…¥åŠ›ã‚·ã‚¹ãƒ†ãƒ **  
- Speech Frameworkå®Ÿè£…
- è‡ªç„¶è¨€èªå‡¦ç†ï¼ˆæ™‚é–“æŠ½å‡ºï¼‰
- éŸ³å£°â†’ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼å¤‰æ›ãƒ­ã‚¸ãƒƒã‚¯
- åŸºæœ¬çš„ãªNLPãƒ‘ãƒ¼ã‚µãƒ¼

**Week 3: é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ **
- Local Notificationå®Ÿè£…
- æ®µéšçš„é€šçŸ¥ãƒ­ã‚¸ãƒƒã‚¯
- é€šçŸ¥ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆå®Œäº†ãƒ»ã‚¹ãƒŒãƒ¼ã‚ºï¼‰
- ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†

**Week 4: å“è³ªå‘ä¸Šãƒ»ç”³è«‹æº–å‚™**
- UI/UXèª¿æ•´ãƒ»ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ä»•ä¸Šã’
- ä¾‹å¤–/ã‚¨ãƒ©ãƒ¼UIã®ç£¨ãè¾¼ã¿
- ã‚¹ãƒˆã‚¢ç´ ææº–å‚™ãƒ»ç”³è«‹æº–å‚™

#### Phase 2: æ‹¡å¼µæ©Ÿèƒ½ï¼ˆ3é€±é–“ï¼‰
- AIå­¦ç¿’æ©Ÿèƒ½
- å¤©æ°—ãƒ»ä½ç½®é€£å‹•
- ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæ©Ÿèƒ½æ‹¡å……
- UI/UXãƒ–ãƒ©ãƒƒã‚·ãƒ¥ã‚¢ãƒƒãƒ—

#### Phase 3: ãƒªãƒªãƒ¼ã‚¹æº–å‚™ï¼ˆ2é€±é–“ï¼‰
- App Storeç”³è«‹
- ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°æº–å‚™
- ãƒã‚°ä¿®æ­£ãƒ»æœ€é©åŒ–

### 1.2 æŠ€è¡“çš„å„ªå…ˆé †ä½

**ğŸš¨ Critical Pathï¼ˆãƒ–ãƒ­ãƒƒã‚«ãƒ¼ã«ãªã‚‹æ©Ÿèƒ½ï¼‰**
1. **Core Data + åŸºæœ¬CRUD** - å…¨æ©Ÿèƒ½ã®åŸºç›¤
2. **éŸ³å£°èªè­˜ + NLP** - ã‚³ã‚¢ä¾¡å€¤ææ¡ˆ
3. **é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ** - å·®åˆ¥åŒ–è¦ç´ 

**âš¡ High Priorityï¼ˆæ—©æœŸå®Ÿè£…ã§ä¾¡å€¤å‘ä¸Šï¼‰**
5. æ®µéšçš„é€šçŸ¥ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
6. å„ªã—ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ³ã‚°
7. ã‚ˆãä½¿ã†ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
8. å®Œäº†æ™‚ã®è¤’ã‚æ©Ÿèƒ½

**ğŸ“ˆ Medium Priorityï¼ˆä½“é¨“å‘ä¸Šï¼‰**
9. éŸ³å£°èªè­˜ç²¾åº¦å‘ä¸Š
10. UI/UXãƒãƒªãƒƒã‚·ãƒ¥
11. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
12. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

## 2. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆæœŸã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

### 2.1 Xcodeãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆæ‰‹é †

```bash
# 1. æ–°è¦ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
# File > New > Project > iOS > App
# Project Name: WasurenBou
# Bundle ID: com.yourcompany.wasurenBou
# Language: Swift, UI: SwiftUI

# 2. watchOS Targetã®è¿½åŠ ã¯å½“é¢ä¸è¦

# 3. å¿…è¦ãªCapabilitiesã‚’æœ‰åŠ¹åŒ–
# Project Settings > Signing & Capabilities:
# - Background Modes (Background processing)
# - Push Notifications  
# - Siri
```

### 2.2 ãƒ•ã‚©ãƒ«ãƒ€æ§‹æˆ
```
WasurenBou/
â”œâ”€â”€ App/
â”‚   â”œâ”€â”€ WasurenBouApp.swift
â”‚   â”œâ”€â”€ ContentView.swift
â”‚   â””â”€â”€ Info.plist
â”œâ”€â”€ Models/
â”‚   â”œâ”€â”€ Reminder.swift
â”‚   â”œâ”€â”€ ReminderTemplate.swift
â”‚   â””â”€â”€ WasurenBou.xcdatamodeld
â”œâ”€â”€ ViewModels/
â”‚   â”œâ”€â”€ ReminderViewModel.swift
â”‚   â””â”€â”€ SpeechViewModel.swift
â”œâ”€â”€ Views/
â”‚   â”œâ”€â”€ ReminderListView.swift
â”‚   â”œâ”€â”€ VoiceInputView.swift
â”‚   â””â”€â”€ Components/
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ ReminderRepository.swift
â”‚   â”œâ”€â”€ NotificationService.swift
â”‚   â”œâ”€â”€ SpeechRecognitionService.swift
â”‚   â””â”€â”€ NLPParser.swift
â”œâ”€â”€ Extensions/
â”‚   â”œâ”€â”€ Date+Extensions.swift
â”‚   â””â”€â”€ String+Extensions.swift
â””â”€â”€ Resources/
    â”œâ”€â”€ Sounds/
    â””â”€â”€ Colors.xcassets
```

### 2.3 åˆæœŸä¾å­˜é–¢ä¿‚è¨­å®š

```swift
// Package.swift ã¾ãŸã¯ SPMã§è¿½åŠ 
dependencies: [
    // å¿…é ˆã§ã¯ãªã„ãŒã€æ¤œè¨å¯¾è±¡
    .package(url: "https://github.com/apple/swift-algorithms", from: "1.0.0"),
]
```

## 3. ã‚³ã‚¢æ©Ÿèƒ½ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—å®Ÿè£…è¨ˆç”»

### 3.1 Week 1: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåŸºç›¤

**Day 1-2: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**
```swift
// WasurenBouApp.swift
@main
struct WasurenBouApp: App {
    let persistenceController = PersistenceController.shared
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environment(\.managedObjectContext, persistenceController.container.viewContext)
        }
    }
}

// PersistenceController.swift  
class PersistenceController {
    static let shared = PersistenceController()
    
    let container: NSPersistentContainer
    
    init() {
        container = NSPersistentContainer(name: "WasurenBou")
        container.loadPersistentStores { _, error in
            if let error = error {
                fatalError("Core Data error: \(error)")
            }
        }
    }
}
```

**Day 3-4: Core Dataãƒ¢ãƒ‡ãƒ«å®Ÿè£…**
```swift
// Reminder+CoreDataClass.swift
@objc(Reminder)
public class Reminder: NSManagedObject {
    // Core Dataè‡ªå‹•ç”Ÿæˆ
}

// Reminder+CoreDataProperties.swift
extension Reminder {
    @NSManaged public var id: UUID
    @NSManaged public var title: String
    @NSManaged public var scheduledTime: Date
    @NSManaged public var isCompleted: Bool
    @NSManaged public var createdAt: Date
}
```

**Day 5: åŸºæœ¬UIå®Ÿè£…**
```swift
// ContentView.swift - æœ€å°æ§‹æˆ
struct ContentView: View {
    @State private var showingVoiceInput = false
    
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                // éŸ³å£°å…¥åŠ›ãƒœã‚¿ãƒ³ï¼ˆãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ï¼‰
                Button("ğŸ¤ è©±ã—ã‹ã‘ã‚‹") {
                    showingVoiceInput = true
                }
                .font(.title2)
                .padding()
                .background(Color.blue.opacity(0.1))
                .cornerRadius(12)
                
                // ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼ä¸€è¦§ï¼ˆãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ï¼‰
                List {
                    Text("ä»Šæ—¥ã®ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼ã¯ã‚ã‚Šã¾ã›ã‚“")
                        .foregroundColor(.gray)
                }
                
                Spacer()
            }
            .navigationTitle("ã‚ã™ã‚Œã‚“æ£’")
        }
    }
}
```

### 3.2 Week 2: éŸ³å£°å…¥åŠ›ã‚·ã‚¹ãƒ†ãƒ 

**Day 1-2: Speech Frameworkå®Ÿè£…**
```swift
// SpeechRecognitionService.swift
import Speech
import AVFoundation

class SpeechRecognitionService: ObservableObject {
    @Published var isRecording = false
    @Published var recognizedText = ""
    @Published var isAuthorized = false
    
    private let speechRecognizer = SFSpeechRecognizer(locale: Locale(identifier: "ja-JP"))
    private var recognitionRequest: SFSpeechAudioBufferRecognitionRequest?
    private var recognitionTask: SFSpeechRecognitionTask?
    private let audioEngine = AVAudioEngine()
    
    init() {
        Task {
            await requestPermissions()
        }
    }
    
    @MainActor
    private func requestPermissions() async {
        // éŸ³å£°èªè­˜æ¨©é™
        let speechStatus = await withCheckedContinuation { continuation in
            SFSpeechRecognizer.requestAuthorization { status in
                continuation.resume(returning: status)
            }
        }
        
        // ãƒã‚¤ã‚¯æ¨©é™
        let micStatus = await withCheckedContinuation { continuation in
            AVAudioSession.sharedInstance().requestRecordPermission { granted in
                continuation.resume(returning: granted)
            }
        }
        
        self.isAuthorized = speechStatus == .authorized && micStatus
    }
    
    func startRecording() throws {
        // å‰ã®èªè­˜ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        recognitionTask?.cancel()
        recognitionTask = nil
        
        // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒã‚·ãƒ§ãƒ³è¨­å®š
        let audioSession = AVAudioSession.sharedInstance()
        try audioSession.setCategory(.record, mode: .measurement, options: .duckOthers)
        try audioSession.setActive(true, options: .notifyOthersOnDeactivation)
        
        // èªè­˜ãƒªã‚¯ã‚¨ã‚¹ãƒˆä½œæˆ
        recognitionRequest = SFSpeechAudioBufferRecognitionRequest()
        guard let recognitionRequest = recognitionRequest else {
            throw SpeechError.recognitionRequestFailed
        }
        
        recognitionRequest.shouldReportPartialResults = true
        
        // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚¨ãƒ³ã‚¸ãƒ³è¨­å®š
        let inputNode = audioEngine.inputNode
        let recordingFormat = inputNode.outputFormat(forBus: 0)
        
        inputNode.installTap(onBus: 0, bufferSize: 1024, format: recordingFormat) { buffer, _ in
            recognitionRequest.append(buffer)
        }
        
        // èªè­˜é–‹å§‹
        recognitionTask = speechRecognizer?.recognitionTask(with: recognitionRequest) { [weak self] result, error in
            DispatchQueue.main.async {
                if let result = result {
                    self?.recognizedText = result.bestTranscription.formattedString
                }
                
                if error != nil || result?.isFinal == true {
                    self?.stopRecording()
                }
            }
        }
        
        audioEngine.prepare()
        try audioEngine.start()
        
        isRecording = true
        recognizedText = ""
    }
    
    func stopRecording() {
        audioEngine.stop()
        audioEngine.inputNode.removeTap(onBus: 0)
        
        recognitionRequest?.endAudio()
        recognitionRequest = nil
        recognitionTask?.cancel()
        recognitionTask = nil
        
        isRecording = false
    }
}

enum SpeechError: Error {
    case recognitionRequestFailed
    case audioEngineFailed
}
```

**Day 3-4: NLPãƒ‘ãƒ¼ã‚µãƒ¼å®Ÿè£…**
```swift
// NLPParser.swift
import Foundation
import NaturalLanguage

struct ReminderIntent {
    let title: String
    let scheduledTime: Date
    let type: ReminderType
}

enum ReminderType {
    case once
    case daily
    case weekly
}

class NLPParser {
    private let calendar = Calendar.current
    private let now = Date()
    
    func parseReminderIntent(from text: String) -> ReminderIntent? {
        let cleanText = text.trimmingCharacters(in: .whitespacesAndNewlines)
        
        // æ™‚é–“è¡¨ç¾ã‚’æŠ½å‡º
        let timeInfo = extractTimeExpression(from: cleanText)
        
        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³éƒ¨åˆ†ã‚’æŠ½å‡ºï¼ˆæ™‚é–“è¡¨ç¾ã‚’é™¤ã„ãŸéƒ¨åˆ†ï¼‰
        let action = extractAction(from: cleanText, removingTime: timeInfo?.originalText)
        
        guard let scheduledTime = timeInfo?.date,
              let actionText = action else {
            return nil
        }
        
        return ReminderIntent(
            title: actionText,
            scheduledTime: scheduledTime,
            type: .once
        )
    }
    
    private func extractTimeExpression(from text: String) -> (date: Date, originalText: String)? {
        // "2æ™‚é–“å¾Œ" -> Date(now + 2 hours)
        if let match = text.range(of: #"(\d+)æ™‚é–“å¾Œ"#, options: .regularExpression) {
            let matchText = String(text[match])
            if let hours = Int(matchText.replacingOccurrences(of: #"(\d+)æ™‚é–“å¾Œ"#, with: "$1", options: .regularExpression)) {
                return (now.addingTimeInterval(TimeInterval(hours * 3600)), matchText)
            }
        }
        
        // "æ˜æ—¥æœä¸€" -> Date(tomorrow 8:00)
        if text.contains("æ˜æ—¥æœä¸€") || text.contains("æ˜æ—¥ã®æœä¸€") {
            let tomorrow = calendar.date(byAdding: .day, value: 1, to: now)!
            let morningTime = calendar.date(bySettingHour: 8, minute: 0, second: 0, of: tomorrow)!
            return (morningTime, "æ˜æ—¥æœä¸€")
        }
        
        // "30åˆ†å¾Œ" -> Date(now + 30 minutes)  
        if let match = text.range(of: #"(\d+)åˆ†å¾Œ"#, options: .regularExpression) {
            let matchText = String(text[match])
            if let minutes = Int(matchText.replacingOccurrences(of: #"(\d+)åˆ†å¾Œ"#, with: "$1", options: .regularExpression)) {
                return (now.addingTimeInterval(TimeInterval(minutes * 60)), matchText)
            }
        }
        
        return nil
    }
    
    private func extractAction(from text: String, removingTime timeText: String?) -> String? {
        var actionText = text
        
        // æ™‚é–“è¡¨ç¾ã‚’é™¤å»
        if let timeText = timeText {
            actionText = actionText.replacingOccurrences(of: timeText, with: "")
        }
        
        // ã€Œã«ã€ã€Œã‚’ã€ãªã©ã®åŠ©è©ã‚‚é™¤å»
        actionText = actionText
            .replacingOccurrences(of: "ã«", with: "")
            .replacingOccurrences(of: "ã‚’", with: "")
            .trimmingCharacters(in: .whitespacesAndNewlines)
        
        return actionText.isEmpty ? nil : actionText
    }
}
```

### 3.3 Week 3: é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 

**Day 1-2: åŸºæœ¬é€šçŸ¥å®Ÿè£…**
```swift
// NotificationService.swift
import UserNotifications

class NotificationService {
    static let shared = NotificationService()
    
    func requestPermission() async -> Bool {
        let center = UNUserNotificationCenter.current()
        do {
            let granted = try await center.requestAuthorization(options: [.alert, .sound, .badge, .criticalAlert])
            return granted
        } catch {
            return false
        }
    }
    
    func scheduleReminder(_ reminder: Reminder) async throws {
        let center = UNUserNotificationCenter.current()
        
        // æ—¢å­˜ã®é€šçŸ¥ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        center.removePendingNotificationRequests(withIdentifiers: [reminder.id.uuidString])
        
        // åŸºæœ¬é€šçŸ¥ã‚’ä½œæˆ
        let content = UNMutableNotificationContent()
        content.title = reminder.title
        content.body = "æ™‚é–“ã§ã™ã‚ˆã€œ"
        content.sound = .default
        content.categoryIdentifier = "REMINDER_CATEGORY"
        
        // ãƒˆãƒªã‚¬ãƒ¼ä½œæˆ
        let components = Calendar.current.dateComponents([.year, .month, .day, .hour, .minute], 
                                                        from: reminder.scheduledTime)
        let trigger = UNCalendarNotificationTrigger(dateMatching: components, repeats: false)
        
        // ãƒªã‚¯ã‚¨ã‚¹ãƒˆä½œæˆ
        let request = UNNotificationRequest(
            identifier: reminder.id.uuidString,
            content: content, 
            trigger: trigger
        )
        
        try await center.add(request)
    }
}
```

**Day 3-5: æ®µéšçš„é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ **
```swift
// NotificationService.swift ã«è¿½åŠ 
func scheduleEscalatingReminders(for reminder: Reminder) async throws {
    let center = UNUserNotificationCenter.current()
    let baseId = reminder.id.uuidString
    
    // 1å›ç›®: å„ªã—ã„é€šçŸ¥
    let first = createEscalatingNotification(
        id: "\(baseId)-1",
        title: reminder.title,
        body: "æ™‚é–“ã§ã™ã‚ˆã€œ",
        time: reminder.scheduledTime,
        sound: .default,
        critical: false
    )
    
    // 2å›ç›®: ä¸­ç¨‹åº¦é€šçŸ¥ï¼ˆ5åˆ†å¾Œï¼‰
    let second = createEscalatingNotification(
        id: "\(baseId)-2", 
        title: reminder.title,
        body: "å¤§ä¸ˆå¤«ã§ã™ã‹ï¼Ÿ",
        time: reminder.scheduledTime.addingTimeInterval(300),
        sound: .default,
        critical: false
    )
    
    // 3å›ç›®: ç·Šæ€¥é€šçŸ¥ï¼ˆ10åˆ†å¾Œï¼‰
    let third = createEscalatingNotification(
        id: "\(baseId)-3",
        title: reminder.title,
        body: "ï¼ï¼",
        time: reminder.scheduledTime.addingTimeInterval(600), 
        sound: .defaultCritical,
        critical: true
    )
    
    try await center.add(first)
    try await center.add(second)
    try await center.add(third)
}

private func createEscalatingNotification(
    id: String,
    title: String,
    body: String,
    time: Date,
    sound: UNNotificationSound,
    critical: Bool
) -> UNNotificationRequest {
    let content = UNMutableNotificationContent()
    content.title = title
    content.body = body
    content.sound = sound
    content.categoryIdentifier = "REMINDER_CATEGORY"
    
    if critical {
        content.interruptionLevel = .critical
    }
    
    let components = Calendar.current.dateComponents([.year, .month, .day, .hour, .minute], from: time)
    let trigger = UNCalendarNotificationTrigger(dateMatching: components, repeats: false)
    
    return UNNotificationRequest(identifier: id, content: content, trigger: trigger)
}
```

## 4. ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã¨å“è³ªä¿è¨¼

### 4.1 ãƒ†ã‚¹ãƒˆè¨ˆç”»

**Unit Tests (Week 1-4ã§ä¸¦è¡Œå®Ÿè£…)**
```swift
// ReminderRepositoryTests.swift
import XCTest
@testable import WasurenBou

class ReminderRepositoryTests: XCTestCase {
    var repository: ReminderRepository!
    var mockContext: NSManagedObjectContext!
    
    override func setUp() {
        // ãƒ†ã‚¹ãƒˆç”¨In-Memory Core Dataã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
    }
    
    func testSaveReminder() async throws {
        // Given
        let reminder = Reminder(title: "ãƒ†ã‚¹ãƒˆ", scheduledTime: Date())
        
        // When
        try await repository.saveReminder(reminder)
        
        // Then
        let saved = await repository.fetchActiveReminders()
        XCTAssertEqual(saved.count, 1)
    }
}

// NLPParserTests.swift
class NLPParserTests: XCTestCase {
    var parser: NLPParser!
    
    func testParseTimeExpression() {
        // Given
        let text = "2æ™‚é–“å¾Œã«æ´—æ¿¯ç‰©å–ã‚Šè¾¼ã‚€"
        
        // When
        let intent = parser.parseReminderIntent(from: text)
        
        // Then
        XCTAssertNotNil(intent)
        XCTAssertEqual(intent?.title, "æ´—æ¿¯ç‰©å–ã‚Šè¾¼ã‚€")
    }
}
```

**Integration Tests**
```swift
// SpeechToReminderIntegrationTests.swift
class SpeechToReminderIntegrationTests: XCTestCase {
    func testFullWorkflow() async throws {
        // éŸ³å£°èªè­˜ â†’ NLP â†’ ãƒ‡ãƒ¼ã‚¿ä¿å­˜ â†’ é€šçŸ¥è¨­å®šã®å…¨ãƒ•ãƒ­ãƒ¼
    }
}
```

**UI Testsï¼ˆWeek 4ï¼‰**
```swift
// WasurenBouUITests.swift
class WasurenBouUITests: XCTestCase {
    func testVoiceInputFlow() throws {
        let app = XCUIApplication()
        app.launch()
        
        // éŸ³å£°å…¥åŠ›ãƒœã‚¿ãƒ³ã‚’ã‚¿ãƒƒãƒ—
        app.buttons["ğŸ¤ è©±ã—ã‹ã‘ã‚‹"].tap()
        
        // æ¨©é™ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª
        // ï¼ˆå®Ÿéš›ã®éŸ³å£°ãƒ†ã‚¹ãƒˆã¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã§ã¯å›°é›£ï¼‰
    }
}
```

### 4.2 å“è³ªä¿è¨¼ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

**ã‚³ãƒ¼ãƒ‰å“è³ª**
- [ ] SwiftLintè¨­å®šã¨ãƒ«ãƒ¼ãƒ«éµå®ˆ
- [ ] Code Coverage 80%ä»¥ä¸Š
- [ ] ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãƒã‚§ãƒƒã‚¯ï¼ˆInstrumentsï¼‰
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆï¼ˆéŸ³å£°èªè­˜ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ï¼‰

**æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ**
- [ ] éŸ³å£°èªè­˜ã®ç²¾åº¦ãƒ†ã‚¹ãƒˆï¼ˆæ§˜ã€…ãªè©±ã—æ–¹ï¼‰
- [ ] é€šçŸ¥ã®ç¢ºå®Ÿæ€§ãƒ†ã‚¹ãƒˆï¼ˆãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰çŠ¶æ…‹ï¼‰
- [ ] Apple Watché€£æºãƒ†ã‚¹ãƒˆï¼ˆå½“é¢å¯¾è±¡å¤–ï¼‰
- [ ] ç•°å¸¸ç³»ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

**ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ**
- [ ] åˆå›åˆ©ç”¨æ™‚ã®ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
- [ ] æ¨©é™å–å¾—ãƒ•ãƒ­ãƒ¼ã®ã‚¹ãƒ ãƒ¼ã‚ºã•
- [ ] ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®åˆ†ã‹ã‚Šã‚„ã™ã•

## 5. ãƒªã‚¹ã‚¯ç®¡ç†ã¨å¯¾ç­–

### 5.1 æŠ€è¡“ãƒªã‚¹ã‚¯

**é«˜ãƒªã‚¹ã‚¯**
- **éŸ³å£°èªè­˜ç²¾åº¦**: æ–¹è¨€ãƒ»ãƒã‚¤ã‚ºç’°å¢ƒã§ã®èªè­˜å¤±æ•—
  - å¯¾ç­–: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›UIå®Ÿè£…
- **é€šçŸ¥åˆ¶é™**: iOSé€šçŸ¥åˆ¶é™ã«ã‚ˆã‚‹é€šçŸ¥å¤±æ•—
  - å¯¾ç­–: Critical Alertæ¨©é™ç”³è«‹ã€ä»£æ›¿ã‚¢ãƒ©ãƒ¼ãƒˆæ‰‹æ®µ

**ä¸­ãƒªã‚¹ã‚¯** 
- **Apple Watchæ¥ç¶š**: Bluetoothæ¥ç¶šä¸å®‰å®š
  - å¯¾ç­–: æ¥ç¶šçŠ¶æ³ã«å¿œã˜ãŸUIè¡¨ç¤ºã€å†æ¥ç¶šæ©Ÿèƒ½
- **ãƒãƒƒãƒ†ãƒªãƒ¼æ¶ˆè²»**: é »ç¹é€šçŸ¥ã«ã‚ˆã‚‹ãƒãƒƒãƒ†ãƒªãƒ¼ãƒ‰ãƒ¬ã‚¤ãƒ³
  - å¯¾ç­–: é€šçŸ¥é »åº¦ã®æœ€é©åŒ–ã€çœé›»åŠ›ãƒ¢ãƒ¼ãƒ‰

### 5.2 ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒªã‚¹ã‚¯

**Weekå˜ä½ã®ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³**
- Week 1çµ‚äº†: åŸºæœ¬UIå‹•ä½œ â†’ é…ã‚Œã®å ´åˆã¯Apple Watchå¯¾å¿œã‚’å¾Œå›ã—
- Week 2çµ‚äº†: éŸ³å£°å…¥åŠ›å‹•ä½œ â†’ é…ã‚Œã®å ´åˆã¯ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã§ä»£æ›¿
- Week 3çµ‚äº†: é€šçŸ¥å‹•ä½œ â†’ é…ã‚Œã®å ´åˆã¯æ®µéšçš„é€šçŸ¥ã¯ç°¡ç•¥åŒ–

ã“ã‚Œã§é–‹ç™ºè¨ˆç”»ãŒå®Œæˆã§ã™ï¼å®Ÿè£…ã‚’å§‹ã‚ã‚‹ã¨ã—ãŸã‚‰ã€ã©ã®æ©Ÿèƒ½ã‹ã‚‰ç€æ‰‹ã—ãŸã„ã§ã—ã‚‡ã†ã‹ï¼Ÿ

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"id": "1", "content": "\u5b9f\u88c5\u512a\u5148\u5ea6\u3068\u958b\u767a\u30ed\u30fc\u30c9\u30de\u30c3\u30d7\u306e\u7b56\u5b9a", "status": "completed"}, {"id": "2", "content": "\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u521d\u671f\u30bb\u30c3\u30c8\u30a2\u30c3\u30d7\u624b\u9806", "status": "completed"}, {"id": "3", "content": "\u30b3\u30a2\u6a5f\u80fd\u306e\u30d7\u30ed\u30c8\u30bf\u30a4\u30d7\u5b9f\u88c5\u8a08\u753b", "status": "completed"}, {"id": "4", "content": "\u30c6\u30b9\u30c8\u6226\u7565\u3068\u54c1\u8cea\u4fdd\u8a3c\u8a08\u753b", "status": "completed"}]